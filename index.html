<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>ãƒ©ãƒ©ãƒ©ãƒ³ãƒŠãƒ¼</title> <!-- 1. ã‚²ãƒ¼ãƒ åå¤‰æ›´ -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  
  <!-- 2. PWAå¯¾å¿œ ãƒ¡ã‚¿ã‚¿ã‚° -->
  <meta name="theme-color" content="#87ceeb"/>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="ãƒ©ãƒ©ãƒ©ãƒ³ãƒŠãƒ¼">
  
  <!-- 2. PWAå¯¾å¿œ ã‚¢ã‚¤ã‚³ãƒ³ (ç°¡æ˜“) -->
  <link rel="apple-touch-icon" href="https://placehold.co/192x192/87ceeb/000000?text=ğŸƒâ€â™‚ï¸">
  
  <!-- 2. PWAå¯¾å¿œ manifest (ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³åŒ–) -->
  <link rel="manifest" href="data:application/json;base64,ewogICJuYW1lIjogIuODqeODquODqeODg+ODl+ODpyIsCiAgInNob3J0X25hbWUiOiAi44Op44Oq44Op44O744OfIiwKICAic3RhcnRfdXJsIjogIi4iLAogICJkaXNwbGF5IjogInN0YW5kYWxvbmUiLAogICJiYWNrZ3JvdW5kX2NvbG9yIjogIiM4N2NlZWIiLAogICJ0aGVtZV9jb2xvciI6ICIjODdjZWViIiwKICAiaWNvbnMiOiBbCiAgICB7CiAgICAgICJzcmMiOiAiaHR0cHM6Ly9wbGFjZWhvbGQuY28vMTkyeDE5Mi84N2NlZWIvMDAwMDAwP3RleHQ9JUZ hydraulicsJODiAleOAiLAogICAgICAidHlwZSI6ICJpbWFnZS9wbmciLAogICAgICAic2l6ZXMiOiAiMTkyeDE5MiIKICAgIH0sCiAgICB7CiAgICAgICJzcmMiOiAiaHR0cHM6Ly9wbGFjZWhvbGQuY28vNTEyeDUxMi84N2NlZWIvMDAwMDAwP3RleHQ9JUZ hydraulicsJODiAleOAiLAogICAgICAidHlwZSI6ICJpbWFnZS9wbmciLAogICAgICAic2l6ZXMiOiAiNTEyeDUxMiIKICAgIH0KICBdCn0=">
  
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: #87ceeb; /* ç©ºã®è‰² */
    }
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    canvas {
      display: block;
      touch-action: none;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>

  <script>
    // ==========================
    // åŸºæœ¬è¨­å®šãƒ»ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
    // ==========================
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    let player;
    let playerBaseX = 0;

    let walls = [];
    let platforms = [];
    let items = [];
    let birds = []; // ğŸ¦‡, ğŸ’£, ğŸŒ¶ï¸, ğŸŒ€
    let bees = [];
    let ghosts = [];
    let turtles = [];
    let mushrooms = [];
    let holes = [];
    let floatTexts = [];

    let score = 0;
    let gameOver = false;
    let isTouching = false;
    let prevIsTouching = false;

    let lastTime = 0;

    const BASE_SCROLL_SPEED = 240;
    const GRAVITY = 900;
    const GROUND_RATIO = 0.8;
    const TOP_LIMIT = 20;

    let spawnTimer = 0;
    let nextSpawnTime = 1.0;

    // --- ãƒ¢ãƒ¼ãƒ‰ç®¡ç† ---
    let isChickMode = false;
    let chickTimer = 0;
    const CHICK_MODE_DURATION = 4.0;

    let isBikeMode = false;
    let bikeTimer = 0;
    const BIKE_MODE_DURATION = CHICK_MODE_DURATION * 3;

    // â­ç„¡æ•µãƒ¢ãƒ¼ãƒ‰
    let isStarMode = false;
    let starTimer = 0;
    const STAR_MODE_DURATION = 10.0; // 4. æ™‚é–“ã‚’2å€ (5.0 -> 10.0)

    // --- ãƒ©ã‚¤ãƒ•ç®¡ç† ---
    let lives = 3;
    let invincibleTimer = 0;
    const INVINCIBLE_TIME = 0.8;

    // --- ã‚¸ãƒ£ãƒ³ãƒ—ç®¡ç† ---
    let jumpUsesLeft = 2;
    let isCurrentlyThrusting = false;

    // --- ã‚¹ãƒ¯ã‚¤ãƒ—åˆ¤å®š ---
    let touchStartY = null;

    // --- ãƒ­ã‚¹ãƒˆè¡¨ç¤ºï¼†ä¸€æ™‚åœæ­¢ ---
    let lostMessageTimer = 0;
    let isRespawnPause = false;
    let respawnPauseTimer = 0;

    // --- ç›´å‰ã«ã‚„ã‚‰ã‚ŒãŸä½ç½® ---
    let lastDeathAvoidCenterX = null;

    // 8. å”è¾›å­ éœ‡ãˆå‡¦ç†
    let isShaking = false;
    let shakeTimer = 0;
    const SHAKE_DURATION = 1.0;
    let shakeOffsetX = 0;

    // 9. ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼è¡¨ç¤ºã‚¿ã‚¤ãƒãƒ¼
    let gameOverDisplayTimer = 0;
    const GAME_OVER_DISPLAY_DURATION = 3.0;

    // 13. ã‚¹ã‚¿ãƒ¼ãƒˆæ™‚èª¬æ˜
    let showInstructions = false;
    let instructionTimer = 0;
    const INSTRUCTION_DURATION = 2.0;
    const instructionText = "èµ°ã‚Šæ–¹\nç”»é¢ã‚’æŠ¼ã™ã¨ã‚¸ãƒ£ãƒ³ãƒ—\n1å›ã ã‘ï¼’æ®µã‚¸ãƒ£ãƒ³ãƒ—ã§ãã‚‹\né•·æŠ¼ã—ã§ãƒ­ãƒ³ã‚°ã‚¸ãƒ£ãƒ³ãƒ—\nä¸‹ã«ãªãã‚‹ã¨å³è½ã¡";

    // ==========================
    // ã‚µã‚¦ãƒ³ãƒ‰ï¼ˆã‚¤ãƒ™ãƒ³ãƒˆéŸ³ã®ã¿ï¼šBGMãªã—ï¼‰
    // ==========================
    let audioCtx = null;

    function initAudio() {
      if (!audioCtx) {
        const AC = window.AudioContext || window.webkitAudioContext;
        if (AC) {
          audioCtx = new AC();
        }
      }
    }

    function resumeAudio() {
      if (audioCtx && audioCtx.state === "suspended") {
        audioCtx.resume();
      }
    }



    function playBeep(f, duration, type = "sine", volume = 0.3) {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = type;
      osc.frequency.value = f;
      osc.connect(gain);
      gain.connect(audioCtx.destination);

      const now = audioCtx.currentTime;
      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.exponentialRampToValueAtTime(volume, now + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.001, now + duration);

      osc.start(now);
      osc.stop(now + duration + 0.05);
    }

    // ã‚¤ãƒ™ãƒ³ãƒˆåˆ¥éŸ³
    function playScoreItemSound() {
      playBeep(880, 0.10, "sine", 0.25);
      setTimeout(() => playBeep(1320, 0.10, "sine", 0.2), 90);
    }
    function playChickSound() {
      playBeep(660, 0.12, "triangle", 0.3);
      setTimeout(() => playBeep(990, 0.12, "triangle", 0.25), 120);
    }
    function playBikeSound() {
      playBeep(440, 0.10, "square", 0.3);
      setTimeout(() => playBeep(660, 0.10, "square", 0.25), 110);
      setTimeout(() => playBeep(880, 0.10, "square", 0.2), 220);
    }
    function playBikeBonusSound() {
      playBeep(1200, 0.08, "sawtooth", 0.3);
      setTimeout(() => playBeep(1600, 0.12, "sawtooth", 0.25), 80);
    }
    function playHitSound() {
      playBeep(220, 0.25, "square", 0.35);
      setTimeout(() => playBeep(180, 0.25, "square", 0.3), 180);
    }
    // â­å–å¾—æ™‚
    function playStarItemSound() {
      playBeep(1000, 0.08, "sawtooth", 0.3);
      setTimeout(() => playBeep(1300, 0.08, "sawtooth", 0.25), 80);
      setTimeout(() => playBeep(1600, 0.10, "sawtooth", 0.2), 160);
    }
    // â­ä¸­ã«æ•µã‚’å€’ã—ãŸæ™‚
    function playStarHitSound() {
      playBeep(1500, 0.06, "square", 0.3);
      setTimeout(() => playBeep(1800, 0.08, "square", 0.25), 60);
    }

    // ==========================
    // ç”»é¢ã‚µã‚¤ã‚ºãƒ»åœ°é¢
    // ==========================
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      playerBaseX = canvas.width * 0.15;
    }

    function getGroundY() {
      return canvas.height * GROUND_RATIO;
    }

    // ==========================
    // åˆæœŸåŒ–ãƒ»ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ
    // ==========================
    function resetGame() {
      const groundY = getGroundY();
      playerBaseX = canvas.width * 0.15;

      player = {
        x: playerBaseX,
        y: groundY - 40,
        width: 40,
        height: 40,
        vy: 0,
        emoji: "ğŸƒâ€â™‚ï¸",
        angle: 0,
        onGround: true
      };

      walls = [];
      platforms = [];
      items = [];
      birds = [];
      bees = [];
      ghosts = [];
      turtles = [];
      mushrooms = [];
      holes = [];
      floatTexts = [];

      score = 0;
      gameOver = false;
      spawnTimer = 0;
      nextSpawnTime = randomRange(0.8, 1.6);

      isChickMode = false;
      chickTimer = 0;
      isBikeMode = false;
      bikeTimer = 0;
      isStarMode = false;
      starTimer = 0;

      lives = 3;
      invincibleTimer = 0;

      jumpUsesLeft = 2;
      isCurrentlyThrusting = false;
      prevIsTouching = false;

      lostMessageTimer = 0;
      isRespawnPause = false;
      respawnPauseTimer = 0;

      lastDeathAvoidCenterX = null;

      isShaking = false;
      shakeTimer = 0;
      shakeOffsetX = 0;
      
      gameOverDisplayTimer = 0;

      // 13. ã‚¹ã‚¿ãƒ¼ãƒˆæ™‚èª¬æ˜
      showInstructions = true;
      instructionTimer = INSTRUCTION_DURATION;
    }

    // ==========================
    // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
    // ==========================
    function randomRange(min, max) {
      return Math.random() * (max - min) + min;
    }

    function rectsOverlap(a, b) {
      return (
        a.x < b.x + b.width &&
        a.x + a.width > b.x &&
        a.y < b.y + b.height &&
        a.y + a.height > b.y
      );
    }

    function isPlayerOverHole(p) {
      const pxCenter = p.x + p.width / 2;
      for (const hole of holes) {
        if (pxCenter > hole.x && pxCenter < hole.x + hole.width) {
          return true;
        }
      }
      return false;
    }

    // æŒ‡å®šã—ãŸXï¼ˆä¸­å¿ƒï¼‰ãŒç©´ or æ•µ or ç›´å‰æ­»äº¡ãƒã‚¤ãƒ³ãƒˆã®è¿‘ãã‹ã©ã†ã‹
    function isCenterOverHoleOrEnemy(centerX) {
      // ç©´
      for (const hole of holes) {
        if (centerX > hole.x && centerX < hole.x + hole.width) {
          return true;
        }
      }
      // æ•µï¼ˆåœ°ä¸Šãƒ»ç©ºä¸­å«ã‚ï¼‰
      const enemyLists = [turtles, mushrooms, birds, bees, ghosts];
      const margin = 30; // å°‘ã—ã‚†ã¨ã‚Šã‚’æŒã£ã¦é¿ã‘ã‚‹
      for (const list of enemyLists) {
        for (const e of list) {
          const exCenter = e.x + e.width / 2;
          if (Math.abs(centerX - exCenter) < (e.width / 2 + margin)) {
            return true;
          }
        }
      }
      // ç›´å‰ã«æ­»ã‚“ã ä½ç½®ã®è¿‘ã
      const avoidMargin = 80;
      if (lastDeathAvoidCenterX != null) {
        if (Math.abs(centerX - lastDeathAvoidCenterX) < avoidMargin) {
          return true;
        }
      }
      return false;
    }

    // è½ä¸‹ãƒªã‚¹ãƒãƒ¼ãƒ³ç”¨ã®å®‰å…¨ãªXåº§æ¨™ã‚’æ¢ã™
    function findSafeRespawnX() {
      const minX = canvas.width * 0.10;
      const maxX = canvas.width * 0.30;
      const step = 20;

      const candidates = [];
      for (let x = minX; x <= maxX; x += step) {
        candidates.push(x);
      }
      for (let i = candidates.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [candidates[i], candidates[j]] = [candidates[j], candidates[i]];
      }

      for (const x of candidates) {
        const cx = x + player.width / 2;
        if (!isCenterOverHoleOrEnemy(cx)) {
          return x;
        }
      }
      return playerBaseX;
    }

    // ==========================
    // ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ
    // ==========================
    function activateChickMode() {
      isChickMode = true;
      chickTimer = CHICK_MODE_DURATION;
      if (isBikeMode) {
        isBikeMode = false;
        bikeTimer = 0;
      }
      player.emoji = "ğŸ¥";
      playChickSound();
    }

    function activateBikeMode() {
      isBikeMode = true;
      bikeTimer = BIKE_MODE_DURATION;
      if (isChickMode) {
        isChickMode = false;
        chickTimer = 0;
      }
      player.emoji = "ğŸš´";
      playBikeSound();
    }

    function activateStarMode() {
      isStarMode = true;
      starTimer = STAR_MODE_DURATION; // 10ç§’
      playStarItemSound();
    }

    function updateModeTimers(dt) {
      if (isChickMode) {
        chickTimer -= dt;
        if (chickTimer <= 0) {
          isChickMode = false;
          chickTimer = 0;
          if (!isBikeMode) player.emoji = "ğŸƒâ€â™‚ï¸";
        }
      }
      if (isBikeMode) {
        bikeTimer -= dt;
        if (bikeTimer <= 0) {
          isBikeMode = false;
          bikeTimer = 0;
          if (!isChickMode) player.emoji = "ğŸƒâ€â™‚ï¸";
        }
      }
      if (isStarMode) {
        starTimer -= dt;
        if (starTimer <= 0) {
          isStarMode = false;
          starTimer = 0;
        }
      }
    }

    function getCurrentScrollSpeed() {
      // 13. èª¬æ˜è¡¨ç¤ºä¸­ã¯åœæ­¢
      // 9. ãƒ­ã‚¹ãƒˆæ¼”å‡ºä¸­ã¯åœæ­¢
      // 8. éœ‡ãˆä¸­ã¯åœæ­¢
      if (isRespawnPause || isShaking) return 0;
      
      // 5. â­ãƒ¢ãƒ¼ãƒ‰ã¯æœ€å„ªå…ˆã§é«˜é€ŸåŒ–
      if (isStarMode) return BASE_SCROLL_SPEED * 1.5;

      let speed = BASE_SCROLL_SPEED;
      if (isChickMode) speed = BASE_SCROLL_SPEED * 0.6;
      if (isBikeMode)  speed = BASE_SCROLL_SPEED * 1.3;
      return speed;
    }

    // ==========================
    // ãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç†
    // ==========================
    function damagePlayer(options = {}) {
      if (invincibleTimer > 0 || gameOver) return;

      lives--;
      playHitSound();
      invincibleTimer = INVINCIBLE_TIME;
      lostMessageTimer = 3.0; // 9. 3ç§’è¡¨ç¤º

      if (lives <= 0) {
        gameOver = true;
        gameOverDisplayTimer = GAME_OVER_DISPLAY_DURATION; // 9. 3ç§’ã‚¿ã‚¤ãƒãƒ¼ã‚»ãƒƒãƒˆ
        return;
      }
      
      // 1. ãƒ­ã‚¹ãƒˆå‹•ä½œå¤‰æ›´
      if (options.respawnFromTop) {
        // ã€ãƒ‘ã‚¿ãƒ¼ãƒ³Aã€‘ç©´è½ã¡ã€ã¾ãŸã¯æ•µãƒ’ãƒƒãƒˆå¾Œã®ãƒªã‚¹ãƒãƒ¼ãƒ³
        // ç”»é¢ä¸Šã‹ã‚‰ãƒªã‚¹ãƒãƒ¼ãƒ³ã™ã‚‹
        const safeX = findSafeRespawnX();
        player.x = safeX;
        playerBaseX = safeX;

        player.y = -player.height - 10;
        player.vy = 300;
        player.onGround = false;
        
        // ãƒ¢ãƒ¼ãƒ‰è§£é™¤
        isChickMode = false;
        chickTimer = 0;
        isBikeMode = false;
        bikeTimer = 0;
        isStarMode = false;
        starTimer = 0;
        player.emoji = "ğŸƒâ€â™‚ï¸";

        isRespawnPause = true;
        respawnPauseTimer = 3.2; // (3.0 + 0.2)
      } else {
        // ã€ãƒ‘ã‚¿ãƒ¼ãƒ³Bã€‘æ•µãƒ’ãƒƒãƒˆã€å£ã‚¯ãƒ©ãƒƒã‚·ãƒ¥
        // 1. ä¸Šã«é£›ã³ä¸ŠãŒã£ã¦ç”»é¢ä¸‹ã«æ¶ˆãˆã‚‹å‹•ä½œ
        player.vy = -400; // ä¸Šã«é£›ã³ä¸ŠãŒã‚‹
        player.onGround = false;
        jumpUsesLeft = 0;
        isCurrentlyThrusting = false;

        // ãƒ’ãƒƒãƒˆã—ãŸç¬é–“ã«ãƒ¢ãƒ¼ãƒ‰è§£é™¤
        isChickMode = false;
        chickTimer = 0;
        isBikeMode = false;
        bikeTimer = 0;
        isStarMode = false;
        starTimer = 0;
        player.emoji = "ğŸƒâ€â™‚ï¸";
        
        // ã“ã®å¾Œã€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ç”»é¢ä¸‹ã«è½ã¡ã¦ã„ãã€
        // update() ã® (player.y > canvas.height) ã§
        // ãƒªã‚¹ãƒãƒ¼ãƒ³å‡¦ç†ãŒå®Ÿè¡Œã•ã‚Œã‚‹
      }
    }

    // ==========================
    // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç”Ÿæˆ
    // ==========================
    function spawnObject() {
      const groundY = getGroundY();
      const x = canvas.width + 40;

      // 12. ç©ºä¸­å£/éšæ®µ ã®ãŸã‚ã« "air_wall" ã‚’è¿½åŠ 
      const categories = [
        "score", "score", "score",
        "chick",
        "bike",
        "wall",
        "stairs", // 12. éšæ®µ (50%ã§ç©ºä¸­åŒ–)
        "air_wall", // 12. ç©ºä¸­å£
        "turtle",
        "mushroom",
        "platform",
        "air", // 3. ğŸ¦‡, 6. ğŸŒ€, 8. ğŸŒ¶ï¸
        "bee",
        "ghost",
        "hole", "hole",
        "star"
      ];

      const type = categories[Math.floor(Math.random() * categories.length)];

      if (type === "score") {
        const foodEmojis = ["ğŸ", "ğŸŒ", "ğŸ•", "ğŸ©", "ğŸ”", "ğŸ‡", "ğŸ°", "ğŸ–"];
        items.push({
          type: "score",
          x,
          y: randomRange(groundY * 0.3, groundY - 120),
          width: 28,
          height: 28,
          emoji: foodEmojis[Math.floor(Math.random() * foodEmojis.length)]
        });
      } else if (type === "chick") {
        items.push({
          type: "chick", x,
          y: randomRange(groundY * 0.3, groundY - 140),
          width: 30, height: 30, emoji: "ğŸ£"
        });
      } else if (type === "bike") {
        items.push({
          type: "bike", x,
          y: randomRange(groundY * 0.3, groundY - 140),
          width: 34, height: 34, emoji: "ğŸš²"
        });
      } else if (type === "wall") {
        // åœ°ä¸Šã®å£
        const wallHeight = randomRange(50, 140);
        walls.push({
          x,
          y: groundY - wallHeight,
          width: 40,
          height: wallHeight
        });
      } else if (type === "air_wall") {
        // 12. ç©ºä¸­å£
        const y = randomRange(groundY * 0.35, groundY * 0.6); // ç©ºä¸­ã®Yåº§æ¨™
        const h = randomRange(50, 140);
        platforms.push({
          x, y, baseY: y, width: 40, height: h,
          isMoving: false,
          isAirWall: true // æç”»ç”¨ãƒ•ãƒ©ã‚°
        });
      } else if (type === "stairs") {
        // 12. éšæ®µ (50%ã§åœ°ä¸Šã€50%ã§ç©ºä¸­)
        const stepCount = Math.random() < 0.5 ? 2 : 3;
        const stepWidth = 40;
        const stepHeight = 35;
        
        const isAirStairs = Math.random() < 0.5;
        const baseY = isAirStairs ? randomRange(groundY * 0.4, groundY * 0.6) : groundY;

        const list = isAirStairs ? platforms : walls;
        const props = isAirStairs ? { isMoving: false, isAirWall: true } : {}; // æç”»ç”¨

        for (let i = 0; i < stepCount; i++) {
          const h = stepHeight * (i + 1);
          list.push({
            x: x + i * stepWidth,
            y: baseY - h,
            width: stepWidth,
            height: h,
            ...props
          });
        }
      } else if (type === "turtle") {
        const h = 32;
        const baseY = groundY - h;
        
        // äº€ã®ã‚¸ãƒ£ãƒ³ãƒ—é«˜ã•ã‚’å¤‰æ›´
        let amp = randomRange(10, 30);
        if (Math.random() < 0.30) { // 30%ã®ç¢ºç‡
          amp *= 3; // 3å€ã®é«˜ã•
        }
        
        turtles.push({
          x, baseY, y: baseY,
          width: 40, height: h,
          emoji: "ğŸ¢",
          amp: amp, // å¤‰æ›´ã—ãŸampã‚’é©ç”¨
          omega: randomRange(2.0, 4.0),
          phase: Math.random() * Math.PI * 2
        });
      } else if (type === "mushroom") {
        const h = 32;
        mushrooms.push({
          x, y: groundY - h,
          width: 32, height: h,
          emoji: "ğŸ„"
        });
      } else if (type === "platform") {
        // ç©ºä¸­ã«æµ®ã„ã¦å‹•ã„ã¦ãã‚‹åºŠ (ã‚°ãƒ¬ãƒ¼)
        const platWidth = randomRange(80, 140);
        const platHeight = 16;
        const baseY = randomRange(groundY * 0.35, groundY * 0.6);
        platforms.push({
          x, y: baseY, baseY,
          width: platWidth, height: platHeight,
          amp: randomRange(20, 40),
          omega: randomRange(1.0, 2.0),
          phase: Math.random() * Math.PI * 2,
          isMoving: true,
          isAirWall: false // ã‚°ãƒ¬ãƒ¼æç”»ç”¨
        });
      } else if (type === "air") {
        // 3. ğŸ¦‡, 6. ğŸŒ€, 8. ğŸŒ¶ï¸ ã‚’è¿½åŠ 
        const airEmojis = ["ğŸ¦‡", "ğŸ’£", "ğŸŒ¶ï¸", "ğŸŒ€"];
        const emoji = airEmojis[Math.floor(Math.random() * airEmojis.length)];
        const h = 32;
        const y = randomRange(80, groundY - 130);
        
        if (emoji === "ğŸ¦‡") {
          // 3. ã‚³ã‚¦ãƒ¢ãƒª (å¤§ããä¸Šä¸‹å‹•)
          const baseY = y;
          const amp = randomRange(50, 100); // å¤§ãã
          const omega = randomRange(2.0, 4.0);
          birds.push({
            x, baseY, y: baseY, width: 40, height: h, emoji,
            phase: Math.random() * Math.PI * 2, amp, omega,
            isBat: true, isVortex: false
          });
        } else if (emoji === "ğŸŒ€") {
          // 6. ç«œå·» (å›è»¢)
          birds.push({
            x, y, width: 40, height: h, emoji,
            isBat: false, isVortex: true,
            angle: 0, rotationSpeed: -5.0 // åæ™‚è¨ˆå›ã‚Š
          });
        } else {
          // ğŸ’£ ã¨ ğŸŒ¶ï¸ (ç›´é€²)
          birds.push({
            x, y, width: 40, height: h, emoji,
            isBat: false, isVortex: false
          });
        }
      } else if (type === "bee") {
        const baseY = randomRange(80, groundY - 140);
        const amp = randomRange(20, 50);
        const omega = randomRange(2, 4);
        bees.push({
          x, baseY, y: baseY,
          width: 40, height: 32,
          emoji: "ğŸ",
          phase: Math.random() * Math.PI * 2,
          amp, omega
        });
      } else if (type === "ghost") {
        const baseY = randomRange(80, groundY - 130);
        ghosts.push({
          x, baseY, y: baseY,
          width: 40, height: 32,
          emoji: "ğŸ‘»",
          phase: Math.random() * Math.PI * 2,
          moveState: 1,
          moveTimer: randomRange(0.3, 0.8)
        });
      } else if (type === "hole") {
        const holeWidth = randomRange(80, 140);
        holes.push({ x, width: holeWidth });
      } else if (type === "star") {
        items.push({
          type: "star", x,
          y: randomRange(groundY * 0.25, groundY - 160),
          width: 30, height: 30, emoji: "â­"
        });
      }
    }

    // ==========================
    // å…¥åŠ›ï¼ˆã‚¿ãƒƒãƒ—ãƒ»ã‚¹ãƒ¯ã‚¤ãƒ—ï¼‰
    // ==========================
    function handleTouchStart(e) {
      e.preventDefault();

      // 11. iPhone ã‚µã‚¦ãƒ³ãƒ‰å¯¾å¿œ: æœ€åˆã« init/resume ã‚’å‘¼ã¶
      if (!audioCtx) {
        initAudio();
      }
      resumeAudio();

      // 9. ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ 3ç§’å¾…æ©Ÿ
      if (gameOver) {
        if (gameOverDisplayTimer <= 0) {
          resetGame();
        }
        return; // 3ç§’é–“ã¯ãƒªã‚¹ã‚¿ãƒ¼ãƒˆã•ã›ãªã„
      }
      
      // 13. èª¬æ˜è¡¨ç¤ºä¸­ã¯æ“ä½œã—ãªã„
      if (showInstructions) {
        return;
      }

      isTouching = true;

      const t = e.touches[0];
      touchStartY = t.clientY;
    }

    function handleTouchEnd(e) {
      e.preventDefault();
      isTouching = false;
      touchStartY = null;
    }

    function handleTouchMove(e) {
      e.preventDefault();
      // 13. èª¬æ˜è¡¨ç¤ºä¸­ã¯æ“ä½œã—ãªã„
      if (showInstructions) {
        return;
      }
      if (e.touches.length === 0) return;
      const t = e.touches[0];
      if (touchStartY === null) touchStartY = t.clientY;
      const dy = t.clientY - touchStartY;

      // ä¸‹ã‚¹ãƒ¯ã‚¤ãƒ—ã§é«˜é€Ÿè½ä¸‹
      if (dy > 40 && !player.onGround && !gameOver) {
        isTouching = false;
        isCurrentlyThrusting = false;
        jumpUsesLeft = 0;
        if (player.vy < 900) player.vy = 900;
      }
    }

    function setupInput() {
      canvas.addEventListener("touchstart", handleTouchStart, { passive: false });
      canvas.addEventListener("touchend", handleTouchEnd, { passive: false });
      canvas.addEventListener("touchmove", handleTouchMove, { passive: false });

      document.addEventListener("touchmove", function (e) {
        e.preventDefault();
      }, { passive: false });

      // PCãƒ†ã‚¹ãƒˆç”¨
      canvas.addEventListener("mousedown", (e) => {
        e.preventDefault();
        
        // 11. iPhone ã‚µã‚¦ãƒ³ãƒ‰å¯¾å¿œ
        if (!audioCtx) {
          initAudio();
        }
        resumeAudio();
        
        // 9. ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ 3ç§’å¾…æ©Ÿ
        if (gameOver) {
          if (gameOverDisplayTimer <= 0) {
            resetGame();
          }
          return;
        }
        
        // 13. èª¬æ˜è¡¨ç¤ºä¸­ã¯æ“ä½œã—ãªã„
        if (showInstructions) {
          return;
        }
        
        isTouching = true;
      });
      canvas.addEventListener("mouseup", (e) => {
        e.preventDefault();
        isTouching = false;
      });
      canvas.addEventListener("mouseleave", () => {
        isTouching = false;
      });
    }

    // ==========================
    // ã‚²ãƒ¼ãƒ æ›´æ–°
    // ==========================
    function update(dt) {
      // 13. ã‚¹ã‚¿ãƒ¼ãƒˆæ™‚èª¬æ˜
      if (showInstructions) {
        instructionTimer -= dt;
        if (instructionTimer <= 0) {
          showInstructions = false;
        }
        return; // èª¬æ˜ä¸­ã¯ä»–ã®ã™ã¹ã¦ã‚’åœæ­¢
      }

      // 9. ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼
      if (gameOver) {
        if (gameOverDisplayTimer > 0) {
          gameOverDisplayTimer -= dt;
          if (gameOverDisplayTimer < 0) gameOverDisplayTimer = 0;
        }
        return; // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ä¸­ã‚‚ä»–ã®æ›´æ–°ã¯ã—ãªã„
      }
      
      const groundY = getGroundY();

      // ã‚¿ã‚¤ãƒãƒ¼é¡
      if (invincibleTimer > 0) {
        invincibleTimer -= dt;
        if (invincibleTimer < 0) invincibleTimer = 0;
      }
      if (lostMessageTimer > 0) {
        lostMessageTimer -= dt;
        if (lostMessageTimer < 0) lostMessageTimer = 0;
      }
      if (isRespawnPause) {
        respawnPauseTimer -= dt;
        if (respawnPauseTimer < 0) respawnPauseTimer = 0;
      }
      
      // 8. éœ‡ãˆã‚¿ã‚¤ãƒãƒ¼
      if (isShaking) {
        shakeTimer -= dt;
        if (shakeTimer <= 0) {
          isShaking = false;
          shakeTimer = 0;
          shakeOffsetX = 0;
        } else {
          shakeOffsetX = Math.random() * 10 - 5;
        }
      }

      updateModeTimers(dt);

      const scrollSpeed = getCurrentScrollSpeed();
      const scroll = scrollSpeed * dt;

      // ã‚¿ãƒƒãƒ—ã®ON/OFF
      if (!isTouching && prevIsTouching) {
        if (isCurrentlyThrusting) {
          jumpUsesLeft = Math.max(0, jumpUsesLeft - 1);
          isCurrentlyThrusting = false;
        }
      }

      // 8. éœ‡ãˆä¸­ã¯ã‚¸ãƒ£ãƒ³ãƒ—æ“ä½œä¸å¯
      if (isTouching && !gameOver && !isRespawnPause && !isShaking) {
        if (!isCurrentlyThrusting && jumpUsesLeft > 0) {
          isCurrentlyThrusting = true;
        }
      }

      // 8. éœ‡ãˆä¸­ã¯é‡åŠ›ãƒ»ã‚¸ãƒ£ãƒ³ãƒ—è¨ˆç®—ã‚’ã‚¹ã‚­ãƒƒãƒ— (Yåº§æ¨™å›ºå®š)
      if (!isShaking) {
        if (isCurrentlyThrusting) {
          player.vy = -300;
        } else {
          player.vy += GRAVITY * dt;
        }
      }

      const prevY = player.y;
      player.y += player.vy * dt;

      // ä¸Šé™
      if (player.y < TOP_LIMIT) {
        player.y = TOP_LIMIT;
        if (player.vy < 0) player.vy = 0;
        if (isCurrentlyThrusting) {
          isCurrentlyThrusting = false;
          jumpUsesLeft = Math.max(0, jumpUsesLeft - 1);
        }
      }

      let playerBottom = player.y + player.height;
      let playerTop = player.y;

      // è¶³å ´ï¼ˆå£ï¼‹ç©ºä¸­åºŠï¼‰
      const solids = platforms.concat(walls);
      let onPlatform = false;

      for (const solid of solids) {
        const overlapX =
          player.x + player.width > solid.x &&
          player.x < solid.x + solid.width;
        if (!overlapX) continue;

        // ä¸Šã‹ã‚‰ç€åœ°
        if (
          player.vy >= 0 &&
          playerBottom >= solid.y &&
          playerBottom <= solid.y + solid.height
        ) {
          player.y = solid.y - player.height;
          player.vy = 0;
          playerBottom = player.y + player.height;
          playerTop = player.y;
          onPlatform = true;
          break;
        }

        // ä¸‹ã‹ã‚‰ã¶ã¤ã‹ã£ãŸ
        if (
          player.vy < 0 &&
          playerTop <= solid.y + solid.height &&
          prevY >= solid.y + solid.height
        ) {
          player.y = solid.y + solid.height;
          player.vy = 0;
          playerTop = player.y;
          playerBottom = player.y + player.height;
          break;
        }
      }

      // åœ°é¢ãƒ»ç©´
      let onGroundNow = false;
      if (!onPlatform && player.vy >= 0 && playerBottom >= groundY) {
        if (!isPlayerOverHole(player)) {
          player.y = groundY - player.height;
          player.vy = 0;
          playerBottom = player.y + player.height;
          playerTop = player.y;
          onGroundNow = true;
        }
      }

      player.onGround = onGroundNow || onPlatform;

      // ç”»é¢ä¸‹ (3. ç©´ãƒã‚°ä¿®æ­£ / 1. ãƒ­ã‚¹ãƒˆå‹•ä½œ)
      if (player.y > canvas.height) { 
        
        const centerX = player.x + player.width / 2;
        // ã©ã®ç©´ã‹ã‚‰è½ã¡ãŸã‹åˆ¤å®š
        let removedHole = false;
        for (let i = 0; i < holes.length; i++) {
          const hole = holes[i];
          if (centerX > hole.x && centerX < hole.x + hole.width) {
            const holeCenter = hole.x + hole.width / 2;
            lastDeathAvoidCenterX = holeCenter;
            holes.splice(i, 1);
            removedHole = true;
            break;
          }
        }
        if (!removedHole) {
          lastDeathAvoidCenterX = centerX;
        }

        if (invincibleTimer <= 0) {
          // ãƒ‘ã‚¿ãƒ¼ãƒ³A (ç©´ã«ãã®ã¾ã¾è½ã¡ãŸ): ãƒ©ã‚¤ãƒ•ã‚’æ¸›ã‚‰ã—ã¦ãƒªã‚¹ãƒãƒ¼ãƒ³
          damagePlayer({ respawnFromTop: true });
        } else {
          // ãƒ‘ã‚¿ãƒ¼ãƒ³B (æ•µãƒ’ãƒƒãƒˆ/å£ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã§ç„¡æ•µæ™‚é–“ä¸­ã«è½ã¡ã¦ããŸ): ãƒ©ã‚¤ãƒ•ã¯æ¸›ã‚‰ã•ãšã€ãƒªã‚¹ãƒãƒ¼ãƒ³å‡¦ç†ã ã‘å®Ÿè¡Œ
          
          // damagePlayer ã® respawnFromTop: true ã®ä¸­èº«ã‚’ã“ã“ã«ã‚³ãƒ”ãƒ¼
          const safeX = findSafeRespawnX();
          player.x = safeX;
          playerBaseX = safeX;

          player.y = -player.height - 10;
          player.vy = 300;
          player.onGround = false;
            
          // ãƒ¢ãƒ¼ãƒ‰è§£é™¤ (æ—¢ã«ã•ã‚Œã¦ã„ã‚‹ã¯ãšã ãŒå¿µã®ãŸã‚)
          isChickMode = false;
          chickTimer = 0;
          isBikeMode = false;
          bikeTimer = 0;
          isStarMode = false;
          starTimer = 0;
          player.emoji = "ğŸƒâ€â™‚ï¸";

          isRespawnPause = true;
          respawnPauseTimer = 3.2; 
        }
      }

      // ã‚¸ãƒ£ãƒ³ãƒ—å›æ•°ãƒªã‚»ãƒƒãƒˆ
      if (player.onGround && player.vy === 0) {
        jumpUsesLeft = 2;
        if (!isTouching) {
          isCurrentlyThrusting = false;
        }
      }

      // èƒŒæ™¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç§»å‹•
      function moveAndFilter(list) {
        return list
          .map(obj => {
            obj.x -= scroll;
            return obj;
          })
          .filter(obj => obj.x + (obj.width || 0) > -50);
      }

      walls = moveAndFilter(walls);
      platforms = moveAndFilter(platforms);
      items = moveAndFilter(items);
      turtles = moveAndFilter(turtles);
      mushrooms = moveAndFilter(mushrooms);
      
      // 3. ğŸ¦‡, 6. ğŸŒ€
      birds = moveAndFilter(birds);
      for (const b of birds) {
        if (b.isBat) { // ã‚³ã‚¦ãƒ¢ãƒª
          b.phase += b.omega * dt;
          b.y = b.baseY + b.amp * Math.sin(b.phase);
        }
        if (b.isVortex) { // ç«œå·»
          b.angle += b.rotationSpeed * dt;
        }
      }

      holes = holes
        .map(hole => {
          hole.x -= scroll;
          return hole;
        })
        .filter(hole => hole.x + hole.width > -50);

      // å‹•ãç©ºä¸­åºŠ
      for (const plat of platforms) {
        if (plat.isMoving) {
          plat.phase += plat.omega * dt;
          plat.y = plat.baseY + plat.amp * Math.sin(plat.phase);
        }
      }

      // äº€
      for (const t of turtles) {
        t.phase += t.omega * dt;
        t.y = t.baseY - Math.abs(Math.sin(t.phase)) * t.amp;
      }

      // èœ‚
      bees = moveAndFilter(bees);
      for (const bee of bees) {
        bee.phase += bee.omega * dt;
        bee.y = bee.baseY + bee.amp * Math.sin(bee.phase);
      }

      // ã‚ªãƒã‚±
      ghosts = ghosts.filter(g => {
        if (g.moveState === 1) {
          g.x -= scroll;
        }
        g.moveTimer -= dt;
        if (g.moveTimer <= 0) {
          g.moveState = g.moveState === 1 ? 0 : 1;
          g.moveTimer = randomRange(0.3, 0.8);
        }
        g.phase += 1.5 * dt;
        g.y = g.baseY + 10 * Math.sin(g.phase);
        return g.x + g.width > -50;
      });

      // å£ã®æ¨ªè¡çª
      let playerRect = {
        x: player.x,
        y: player.y,
        width: player.width,
        height: player.height
      };

      let pushedByWall = false;
      for (const wall of walls) {
        const wallRect = {
          x: wall.x,
          y: wall.y,
          width: wall.width,
          height: wall.height
        };
        if (rectsOverlap(playerRect, wallRect)) {
          player.x = wall.x - player.width;
          playerRect.x = player.x;
          pushedByWall = true;
        }
      }
      // 12. ç©ºä¸­å£/éšæ®µ (platforms ãƒªã‚¹ãƒˆå†…) ã‚‚æ¨ªè¡çªåˆ¤å®š
      for (const plat of platforms) {
        if (plat.isAirWall) { // æ°´è‰²ã®å£/éšæ®µã®ã¿
          const wallRect = {
            x: plat.x,
            y: plat.y,
            width: plat.width,
            height: plat.height
          };
          if (rectsOverlap(playerRect, wallRect)) {
            player.x = plat.x - player.width;
            playerRect.x = player.x;
            pushedByWall = true;
          }
        }
      }


      // å£ã«æŠ¼ã—å‡ºã•ã‚Œã¦ç”»é¢å¤–
      if (player.x + player.width < 0 && invincibleTimer <= 0) {
        lastDeathAvoidCenterX = player.x + player.width / 2;
        damagePlayer(); // 1. ãƒ­ã‚¹ãƒˆå‹•ä½œå¤‰æ›´ (ã‚ªãƒ—ã‚·ãƒ§ãƒ³å‰Šé™¤)
        playerRect.x = player.x;
        playerRect.y = player.y;
      }

      // 8. éœ‡ãˆä¸­ã¯åŸºæº–ä½ç½®ã«æˆ»ã‚‰ãªã„
      if (!pushedByWall && player.x < playerBaseX && !isRespawnPause && !isShaking) {
        const returnSpeed = 300;
        player.x += returnSpeed * dt;
        if (player.x > playerBaseX) player.x = playerBaseX;
        playerRect.x = player.x;
      }

      // æ•µã¨ã®å½“ãŸã‚Šåˆ¤å®š (7. ğŸŒ€, 8. ğŸŒ¶ï¸)
      function handleEnemyHit(list, index, centerX, enemy) {
        lastDeathAvoidCenterX = centerX;

        // â­ãƒ¢ãƒ¼ãƒ‰
        if (isStarMode) {
          const e = enemy || list[index]; // å¼•æ•° or ãƒªã‚¹ãƒˆ
          if (e) {
            score += 30;
            playStarHitSound();
            floatTexts.push({
              x: e.x + e.width / 2,
              y: e.y,
              text: "+30",
              life: 0.8
            });
          }
          list.splice(index, 1);
          return;
        }
        
        // 7. ğŸŒ€ (ç«œå·») ãƒ’ãƒƒãƒˆ: è½ä¸‹
        if (enemy && enemy.emoji === "ğŸŒ€") {
          if (invincibleTimer > 0) return;

          player.vy = GRAVITY * 0.8; // è½ä¸‹
          player.onGround = false;
          jumpUsesLeft = 0;
          isCurrentlyThrusting = false;
          
          list.splice(index, 1);
          return; // damagePlayer å‘¼ã°ãªã„
        }
        
        // 8. ğŸŒ¶ï¸ (å”è¾›å­) ãƒ’ãƒƒãƒˆ: éœ‡ãˆ
        if (enemy && enemy.emoji === "ğŸŒ¶ï¸") {
          if (invincibleTimer > 0) return;

          isShaking = true;
          shakeTimer = SHAKE_DURATION;
          invincibleTimer = SHAKE_DURATION + 0.2; // éœ‡ãˆä¸­ã¯ç„¡æ•µ
          
          list.splice(index, 1);
          playHitSound(); // (éŸ³)
          return; // damagePlayer å‘¼ã°ãªã„
        }

        // è‡ªè»¢è»Šãƒ¢ãƒ¼ãƒ‰
        if (isBikeMode) {
          isBikeMode = false;
          bikeTimer = 0;
          if (!isChickMode) player.emoji = "ğŸƒâ€â™‚ï¸";
          return;
        }

        // é€šå¸¸ãƒ’ãƒƒãƒˆ
        if (invincibleTimer <= 0) {
          list.splice(index, 1);
          damagePlayer(); // 1. ãƒ­ã‚¹ãƒˆå‹•ä½œå¤‰æ›´ (ã‚ªãƒ—ã‚·ãƒ§ãƒ³å‰Šé™¤)
        }
      }

      // äº€
      for (let i = 0; i < turtles.length && !gameOver; i++) {
        if (rectsOverlap(playerRect, turtles[i])) {
          const c = turtles[i].x + turtles[i].width / 2;
          handleEnemyHit(turtles, i, c, turtles[i]);
          break;
        }
      }
      // ã‚­ãƒã‚³
      for (let i = 0; i < mushrooms.length && !gameOver; i++) {
        if (rectsOverlap(playerRect, mushrooms[i])) {
          const c = mushrooms[i].x + mushrooms[i].width / 2;
          handleEnemyHit(mushrooms, i, c, mushrooms[i]);
          break;
        }
      }
      // ğŸ¦‡, ğŸ’£, ğŸŒ¶ï¸, ğŸŒ€
      for (let i = 0; i < birds.length && !gameOver; i++) {
        if (rectsOverlap(playerRect, birds[i])) {
          const c = birds[i].x + birds[i].width / 2;
          handleEnemyHit(birds, i, c, birds[i]);
          break;
        }
      }
      // èœ‚
      for (let i = 0; i < bees.length && !gameOver; i++) {
        if (rectsOverlap(playerRect, bees[i])) {
          const c = bees[i].x + bees[i].width / 2;
          handleEnemyHit(bees, i, c, bees[i]);
          break;
        }
      }
      // ã‚ªãƒã‚±
      for (let i = 0; i < ghosts.length && !gameOver; i++) {
        if (rectsOverlap(playerRect, ghosts[i])) {
          const c = ghosts[i].x + ghosts[i].width / 2;
          handleEnemyHit(ghosts, i, c, ghosts[i]);
          break;
        }
      }

      // ã‚¢ã‚¤ãƒ†ãƒ å–å¾—
      if (!gameOver) {
        items = items.filter(item => {
          if (rectsOverlap(playerRect, item)) {
            let text = "";
            if (item.type === "score") {
              score += 10;
              playScoreItemSound();
              text = "+10";
            } else if (item.type === "chick") {
              activateChickMode();
              text = "ğŸ¥";
            } else if (item.type === "bike") {
              const wasBike = isBikeMode;
              if (wasBike) {
                score += 20;
                playBikeBonusSound();
                text = "+20";
              } else {
                text = "ğŸš´";
              }
              activateBikeMode();
            } else if (item.type === "star") {
              activateStarMode();
              text = "â­";
            }
            floatTexts.push({
              x: item.x + item.width / 2,
              y: item.y,
              text,
              life: 0.8
            });
            return false;
          }
          return true;
        });
      }

      // ã‚¹ã‚³ã‚¢ï¼ˆç”Ÿå­˜æ™‚é–“ï¼‰
      if (!gameOver && !isRespawnPause && !isShaking) {
        score += dt * 5;
      }

      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å›è»¢
      const inNormalMode = !isBikeMode && !isChickMode;
      let baseDir = 1;
      if (isBikeMode || inNormalMode) {
        baseDir = -1;
      } else {
        baseDir = 1;
      }

      let rollDir = baseDir;
      let rollSpeed = 4.0;

      if (isStarMode) {
        rollDir = -baseDir;
        rollSpeed = 10.0;
      }

      player.angle += rollDir * rollSpeed * dt;

      // ãƒ•ãƒ­ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒ†ã‚­ã‚¹ãƒˆ
      floatTexts = floatTexts.filter(ft => {
        ft.y -= 40 * dt;
        ft.life -= dt;
        return ft.life > 0;
      });

      // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç”Ÿæˆ
      if (!isRespawnPause && !isShaking) {
        spawnTimer += dt;
        if (spawnTimer >= nextSpawnTime) {
          spawnObject();
          spawnTimer = 0;
          nextSpawnTime = randomRange(0.8, 1.6);
        }
      }

      // ãƒªã‚¹ãƒãƒ¼ãƒ³ä¸€æ™‚åœæ­¢è§£é™¤ï¼š
      if (isRespawnPause && respawnPauseTimer <= 0 && player.onGround) {
        isRespawnPause = false;
      }

      prevIsTouching = isTouching;
    }

    // ==========================
    // æç”»
    // ==========================
    function draw() {
      const groundY = getGroundY();

      // èƒŒæ™¯ï¼ˆç©ºï¼‰
      ctx.fillStyle = "#87ceeb";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // åœ°é¢
      ctx.fillStyle = "#3c7c1b";
      const sortedHoles = [...holes].sort((a, b) => a.x - b.x);
      let currentX = 0;
      for (const hole of sortedHoles) {
        const segWidth = hole.x - currentX;
        if (segWidth > 0) {
          ctx.fillRect(currentX, groundY, segWidth, canvas.height - groundY);
        }
        currentX = hole.x + hole.width;
      }
      if (currentX < canvas.width) {
        ctx.fillRect(currentX, groundY, canvas.width - currentX, canvas.height - groundY);
      } 

      // å£ (åœ°ä¸Šã®èŒ¶è‰²ã„å£)
      ctx.fillStyle = "#8b4513";
      for (const wall of walls) {
        ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
      }

      // 12. ç©ºä¸­åºŠ (é»„ç·‘/ã‚°ãƒ¬ãƒ¼)
      const airWallColor = "#9acd32"; // 2. ãã™ã¿é»„ç·‘ã«å¤‰æ›´ (å…ƒ: #adff2f)
      const platformColor = "#cccccc"; // ã‚°ãƒ¬ãƒ¼
      for (const plat of platforms) {
        ctx.fillStyle = plat.isAirWall ? airWallColor : platformColor;
        ctx.fillRect(plat.x, plat.y, plat.width, plat.height);
      }

      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
      // 8. éœ‡ãˆã‚ªãƒ•ã‚»ãƒƒãƒˆ
      const cx = player.x + player.width / 2 + (isShaking ? shakeOffsetX : 0);
      const cy = player.y + player.height / 2;
      ctx.save();
      ctx.translate(cx, cy);

      const inNormalMode = !isBikeMode && !isChickMode;
      if (isBikeMode || inNormalMode || isStarMode) {
        ctx.scale(-1, 1);
      }

      ctx.rotate(player.angle);
      ctx.font = "32px system-ui";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(player.emoji, 0, 0);
      ctx.restore();

      // æ•µãƒ»ç©ºä¸­æ•µãƒ»ã‚¢ã‚¤ãƒ†ãƒ 
      ctx.font = "28px system-ui";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      for (const t of turtles) {
        ctx.fillText(t.emoji, t.x + t.width / 2, t.y + t.height / 2);
      }
      for (const m of mushrooms) {
        ctx.fillText(m.emoji, m.x + m.width / 2, m.y + m.height / 2);
      }
      
      // 3. ğŸ¦‡, 6. ğŸŒ€
      for (const b of birds) {
        if (b.isVortex) { // ç«œå·»ã¯å›è»¢
          const bcx = b.x + b.width / 2;
          const bcy = b.y + b.height / 2;
          ctx.save();
          ctx.translate(bcx, bcy);
          ctx.rotate(b.angle);
          ctx.fillText(b.emoji, 0, 0);
          ctx.restore();
        } else { // ğŸ¦‡, ğŸ’£, ğŸŒ¶ï¸ ã¯ãã®ã¾ã¾
          ctx.fillText(b.emoji, b.x + b.width / 2, b.y + b.height / 2);
        }
      }
      for (const bee of bees) {
        ctx.fillText(bee.emoji, bee.x + bee.width / 2, bee.y + bee.height / 2);
      }
      for (const g of ghosts) {
        ctx.fillText(g.emoji, g.x + g.width / 2, g.y + g.height / 2);
      }
      for (const item of items) {
        ctx.fillText(item.emoji, item.x + item.width / 2, item.y + item.height / 2);
      }

      // ãƒ•ãƒ­ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒ†ã‚­ã‚¹ãƒˆ
      for (const ft of floatTexts) {
        const alpha = Math.max(0, ft.life / 0.8);
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.fillStyle = "#ffff00";
        ctx.font = "18px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(ft.text, ft.x, ft.y);
        ctx.restore();
      }

      // ãƒ©ã‚¤ãƒ•
      ctx.fillStyle = "#ff0000";
      ctx.font = "24px system-ui";
      ctx.textAlign = "left";
      ctx.textBaseline = "top";
      ctx.fillText("â¤ï¸".repeat(lives), 10, 10);

      // ã‚¹ã‚³ã‚¢
      ctx.fillStyle = "#000000";
      ctx.font = "20px system-ui";
      ctx.textAlign = "right";
      ctx.textBaseline = "top";
      ctx.fillText("Score: " + Math.floor(score), canvas.width - 16, 10);

      // 13. ã‚¹ã‚¿ãƒ¼ãƒˆæ™‚èª¬æ˜
      if (showInstructions) {
        ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = "#ffffff";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.font = "18px system-ui";

        const lines = instructionText.split('\n');
        const lineHeight = 24;
        const startY = canvas.height / 2 - (lines.length - 1) * lineHeight / 2;

        for (let i = 0; i < lines.length; i++) {
          ctx.fillText(lines[i], canvas.width / 2, startY + i * lineHeight);
        }
      }

      // 10. LOST è¡¨ç¤º -> ã€Œã¶ã£ã¶ãƒ¼ã€
      if (lostMessageTimer > 0 && !gameOver) {
        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,0.4)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#ff4444";
        ctx.font = "32px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("ã¶ã£ã¶ãƒ¼", canvas.width / 2, canvas.height / 2); // å¤‰æ›´
        ctx.restore();
      }

      // 9. Game Over (3ç§’å¾…æ©Ÿ)
      if (gameOver) {
        ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = "#ffffff";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        ctx.font = "36px system-ui";
        ctx.fillText("Game Over", canvas.width / 2, canvas.height / 2 - 20);

        ctx.font = "24px system-ui";
        ctx.fillText("Score: " + Math.floor(score), canvas.width / 2, canvas.height / 2 + 20);

        // 3ç§’çµŒéå¾Œã«ãƒªã‚¹ã‚¿ãƒ¼ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
        if (gameOverDisplayTimer <= 0) {
          ctx.font = "18px system-ui";
          ctx.fillText("ç”»é¢ã‚’ã‚¿ãƒƒãƒ—ã—ã¦ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ", canvas.width / 2, canvas.height / 2 + 60);
        }
      }
    }

    // ==========================
    // ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—
    // ==========================
    function gameLoop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      // dt (ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ ) ã‚’è¨ˆç®—ã€‚ãŸã ã—ã€æ¥µç«¯ã«é•·ã„ãƒ•ãƒ¬ãƒ¼ãƒ ï¼ˆä¾‹ï¼šã‚¿ãƒ–ãŒéã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã ã£ãŸï¼‰
      // ã®å ´åˆã¯ã€ã‚²ãƒ¼ãƒ ãŒç ´ç¶»ã—ãªã„ã‚ˆã†ã« 1/30 (ç´„ 0.033 ç§’) ã‚’ä¸Šé™ã«ã™ã‚‹ã€‚
      let dt = (timestamp - lastTime) / 1000;
      if (dt > 1/30) {
        dt = 1/30;
      }
      lastTime = timestamp;

      update(dt);
      draw();

      requestAnimationFrame(gameLoop);
    }

    // ==========================
    // åˆæœŸåŒ–
    // ==========================
    function init() {
      resizeCanvas();
      resetGame();
      setupInput();
      requestAnimationFrame(gameLoop);
    }

    window.addEventListener("resize", () => {
      resizeCanvas();
      // ãƒªã‚µã‚¤ã‚ºæ™‚ã¯ã‚²ãƒ¼ãƒ ã‚’æœ€åˆã‹ã‚‰ãƒªã‚»ãƒƒãƒˆã™ã‚‹
      resetGame();
    });

    init();
  </script>
</body>
</html>
